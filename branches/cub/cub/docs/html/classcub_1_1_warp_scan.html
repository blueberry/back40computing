<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CUB: cub::WarpScan&lt; T, WARPS, LOGICAL_WARP_THREADS &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classcub_1_1_warp_scan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::WarpScan&lt; T, WARPS, LOGICAL_WARP_THREADS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___simt_coop.html">Cooperative SIMT Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan type provides variants of parallel prefix scan across threads within a CUDA warp...">WarpScan</a> type provides variants of parallel prefix scan across threads within a CUDA warp. </p>
<div class="image">
<img src="warp_scan_logo.png" alt="warp_scan_logo.png"/>
<div class="caption">
.</div></div>
  
 <a href="classcub_1_1_warp_scan.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2bfa864e963cb4965139ac1b6c66d1b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfa864e963cb4965139ac1b6c66d1b7"></a>
typedef _SmemStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a></td></tr>
<tr class="memdesc:a2bfa864e963cb4965139ac1b6c66d1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan type provides variants of parallel prefix scan across threads within a CUDA warp...">WarpScan</a> require shared memory of this type. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated shared memory or <code>union</code>'d with other types to facilitate shared memory reuse. <br/></td></tr>
<tr class="separator:a2bfa864e963cb4965139ac1b6c66d1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix sums</div></td></tr>
<tr class="memitem:adec85c76d951c326e592e364aa63c728"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#adec85c76d951c326e592e364aa63c728">InclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output)</td></tr>
<tr class="memdesc:adec85c76d951c326e592e364aa63c728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp.  <a href="#adec85c76d951c326e592e364aa63c728"></a><br/></td></tr>
<tr class="separator:adec85c76d951c326e592e364aa63c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fa41f9103a9e7a6cad20bb3164a1fe"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a75fa41f9103a9e7a6cad20bb3164a1fe">InclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;local_aggregate)</td></tr>
<tr class="memdesc:a75fa41f9103a9e7a6cad20bb3164a1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>.  <a href="#a75fa41f9103a9e7a6cad20bb3164a1fe"></a><br/></td></tr>
<tr class="separator:a75fa41f9103a9e7a6cad20bb3164a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae27cea962d6907a1d3d83954a2558"><td class="memTemplParams" colspan="2">template&lt;typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:af2ae27cea962d6907a1d3d83954a2558"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#af2ae27cea962d6907a1d3d83954a2558">InclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;local_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:af2ae27cea962d6907a1d3d83954a2558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>.  <a href="#af2ae27cea962d6907a1d3d83954a2558"></a><br/></td></tr>
<tr class="separator:af2ae27cea962d6907a1d3d83954a2558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix sums</div></td></tr>
<tr class="memitem:a2695420235a1ace8817a595a6f930d61"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a2695420235a1ace8817a595a6f930d61">ExclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output)</td></tr>
<tr class="memdesc:a2695420235a1ace8817a595a6f930d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp.  <a href="#a2695420235a1ace8817a595a6f930d61"></a><br/></td></tr>
<tr class="separator:a2695420235a1ace8817a595a6f930d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7eb36709cd7f08f204d6176d5c5ec2a"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aa7eb36709cd7f08f204d6176d5c5ec2a">ExclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;local_aggregate)</td></tr>
<tr class="memdesc:aa7eb36709cd7f08f204d6176d5c5ec2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>.  <a href="#aa7eb36709cd7f08f204d6176d5c5ec2a"></a><br/></td></tr>
<tr class="separator:aa7eb36709cd7f08f204d6176d5c5ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b547cd4f3a07928c411bc3db8eb6d43"><td class="memTemplParams" colspan="2">template&lt;typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:a6b547cd4f3a07928c411bc3db8eb6d43"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a6b547cd4f3a07928c411bc3db8eb6d43">ExclusiveSum</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;local_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:a6b547cd4f3a07928c411bc3db8eb6d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>.  <a href="#a6b547cd4f3a07928c411bc3db8eb6d43"></a><br/></td></tr>
<tr class="separator:a6b547cd4f3a07928c411bc3db8eb6d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix scans</div></td></tr>
<tr class="memitem:a9f0397ded5ce89a8750dc8fe10078f3e"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a9f0397ded5ce89a8750dc8fe10078f3e"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a9f0397ded5ce89a8750dc8fe10078f3e">InclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:a9f0397ded5ce89a8750dc8fe10078f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp.  <a href="#a9f0397ded5ce89a8750dc8fe10078f3e"></a><br/></td></tr>
<tr class="separator:a9f0397ded5ce89a8750dc8fe10078f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71a09a779d9ee35d1241cf0fa0fae06"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ad71a09a779d9ee35d1241cf0fa0fae06"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ad71a09a779d9ee35d1241cf0fa0fae06">InclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;local_aggregate)</td></tr>
<tr class="memdesc:ad71a09a779d9ee35d1241cf0fa0fae06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>.  <a href="#ad71a09a779d9ee35d1241cf0fa0fae06"></a><br/></td></tr>
<tr class="separator:ad71a09a779d9ee35d1241cf0fa0fae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb480d6f31b78bdc242340e8b95a30"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:acceb480d6f31b78bdc242340e8b95a30"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#acceb480d6f31b78bdc242340e8b95a30">InclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;local_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:acceb480d6f31b78bdc242340e8b95a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>.  <a href="#acceb480d6f31b78bdc242340e8b95a30"></a><br/></td></tr>
<tr class="separator:acceb480d6f31b78bdc242340e8b95a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans</div></td></tr>
<tr class="memitem:a0f12aef5d3fa15ff13e59876b2983ce1"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a0f12aef5d3fa15ff13e59876b2983ce1"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a0f12aef5d3fa15ff13e59876b2983ce1">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:a0f12aef5d3fa15ff13e59876b2983ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp.  <a href="#a0f12aef5d3fa15ff13e59876b2983ce1"></a><br/></td></tr>
<tr class="separator:a0f12aef5d3fa15ff13e59876b2983ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b116a8cd2bcc27a7107e3e789328bd"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ac3b116a8cd2bcc27a7107e3e789328bd"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ac3b116a8cd2bcc27a7107e3e789328bd">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T identity, ScanOp scan_op, T &amp;local_aggregate)</td></tr>
<tr class="memdesc:ac3b116a8cd2bcc27a7107e3e789328bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>.  <a href="#ac3b116a8cd2bcc27a7107e3e789328bd"></a><br/></td></tr>
<tr class="separator:ac3b116a8cd2bcc27a7107e3e789328bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889e448ffed5844afa419d9e48bf9754"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:a889e448ffed5844afa419d9e48bf9754"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a889e448ffed5844afa419d9e48bf9754">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T identity, ScanOp scan_op, T &amp;local_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:a889e448ffed5844afa419d9e48bf9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>.  <a href="#a889e448ffed5844afa419d9e48bf9754"></a><br/></td></tr>
<tr class="separator:a889e448ffed5844afa419d9e48bf9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans (without supplied identity)</div></td></tr>
<tr class="memitem:ae84a95431640ff2d450c4b0a98dd826e"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ae84a95431640ff2d450c4b0a98dd826e"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ae84a95431640ff2d450c4b0a98dd826e">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:ae84a95431640ff2d450c4b0a98dd826e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for thread-lane<sub>0</sub> is invalid.  <a href="#ae84a95431640ff2d450c4b0a98dd826e"></a><br/></td></tr>
<tr class="separator:ae84a95431640ff2d450c4b0a98dd826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd34377974a8d71d043c1930a43d5b"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:aa9cd34377974a8d71d043c1930a43d5b"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aa9cd34377974a8d71d043c1930a43d5b">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;local_aggregate)</td></tr>
<tr class="memdesc:aa9cd34377974a8d71d043c1930a43d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for thread-lane<sub>0</sub> is invalid. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>.  <a href="#aa9cd34377974a8d71d043c1930a43d5b"></a><br/></td></tr>
<tr class="separator:aa9cd34377974a8d71d043c1930a43d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bae576a6c632b3cc95628af315065f"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename WarpPrefixOp &gt; </td></tr>
<tr class="memitem:aa5bae576a6c632b3cc95628af315065f"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aa5bae576a6c632b3cc95628af315065f">ExclusiveScan</a> (<a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;local_aggregate, WarpPrefixOp &amp;warp_prefix_op)</td></tr>
<tr class="memdesc:aa5bae576a6c632b3cc95628af315065f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The <code>warp_prefix_op</code> value from thread-thread-lane<sub>0</sub> is applied to all scan outputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>.  <a href="#aa5bae576a6c632b3cc95628af315065f"></a><br/></td></tr>
<tr class="separator:aa5bae576a6c632b3cc95628af315065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt;<br/>
class cub::WarpScan&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;</h3>

<p>The <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan type provides variants of parallel prefix scan across threads within a CUDA warp...">WarpScan</a> type provides variants of parallel prefix scan across threads within a CUDA warp. </p>
<div class="image">
<img src="warp_scan_logo.png" alt="warp_scan_logo.png"/>
<div class="caption">
.</div></div>
 <p><b>Overview</b> </p>
<dl class="section user"><dt></dt><dd>Given a list of input elements and a binary reduction operator, <em>prefix scan</em> produces an output list where each element is computed to be the reduction of the elements occurring earlier in the input list. <em>Prefix sum</em> connotes a prefix scan with the addition operator. The term <em>inclusive</em> means that each result includes the corresponding input operand in the partial sum. The term <em>exclusive</em> means that each result does not include the corresponding input operand in the partial reduction.</dd></dl>
<dl class="section user"><dt></dt><dd>These parallel prefix scan variants assume the input and output lists to be logically partitioned among threads with warp thread-lane-<em>i</em> having the <em>i</em><sup>th</sup> input and output elements. To minimize synchronization overhead for operations involving the cumulative <code>aggregate</code> and <code>warp_prefix_op</code>, these values are only valid in thread-lane<sub>0</sub>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scan input/output element type </td></tr>
    <tr><td class="paramname">WARPS</td><td>The number of "logical" warps performing concurrent warp scans </td></tr>
    <tr><td class="paramname">LOGICAL_WARP_THREADS</td><td><b>[optional]</b> The number of threads per "logical" warp (may be less than the number of hardware warp threads). Default is the warp size associated with the CUDA Compute Capability targeted by the compiler (e.g., 32 warps for SM20).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Important Features and Considerations</b> </p>
<dl class="section user"><dt></dt><dd><ul>
<li>Support for "logical" warps smaller than the physical warp size (e.g., 8 threads).</li>
<li>Support for non-commutative binary associative scan functors.</li>
<li>Support for concurrent scans within multiple warps.</li>
<li>Zero bank conflicts for most types.</li>
<li>After any operation, a subsequent CTA barrier (<code>__syncthreads</code>) is required if the supplied <a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7" title="The operations exposed by WarpScan require shared memory of this type. This opaque storage can be all...">WarpScan::SmemStorage</a> is to be reused/repurposed by the CTA.</li>
<li>The operations are most efficient (lowest instruction overhead) when:<ul>
<li>The data type <code>T</code> is a built-in primitive or CUDA vector type (e.g., <code>short</code>, <code>int2</code>, <code>double</code>, <code>float2</code>, etc.) Otherwise the implementation may use memory fences to prevent reference reordering of non-primitive types.</li>
<li>Performing exclusive scans. The implementation may use guarded shared memory accesses for inclusive scans (other than prefix sum) because no identity element is provided.</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>Algorithm</b> </p>
<dl class="section user"><dt></dt><dd>These parallel prefix scan variants implement a warp-synchronous Kogge-Stone algorithm having <em>O</em>(log<em>n</em>) steps and <em>O</em>(<em>n</em>log<em>n</em>) work complexity, where <em>n</em> = <code>LOGICAL_WARP_THREADS</code> (which defaults to the warp size associated with the CUDA Compute Capability targeted by the compiler). <br/>
<br/>
 <div class="image">
<img src="kogge_stone_scan.png" alt="kogge_stone_scan.png"/>
</div>
 <center><b>Data flow within a 16-thread Kogge-Stone scan construction. Junctions represent binary operators.</b></center> <br/>
</dd></dl>
<p><b>Examples</b></p>
<dl class="section user"><dt></dt><dd><ul>
<li><p class="startli"><b>Example 1:</b> Simple exclusive prefix sum for one warp </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// A parameterized WarpScan type for use with one warp on type int.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan type provides variants of parallel prefix scan across threads within a CUDA warp...">cub::WarpScan&lt;int, 1&gt;</a> WarpScan;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Opaque shared memory for WarpScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7" title="The operations exposed by WarpScan require shared memory of this type. This opaque storage can be all...">WarpScan::SmemStorage</a> smem_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Perform prefix sum of threadIds in first warp</span></div>
<div class="line">    <span class="keywordflow">if</span> (threadIdx.x &lt; 32)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> output, input = threadIdx.x;</div>
<div class="line">        <a class="code" href="classcub_1_1_warp_scan.html#a2695420235a1ace8817a595a6f930d61" title="Computes an exclusive prefix sum in each logical warp.">WarpScan::ExclusiveSum</a>(smem_storage, input, output);</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;tid(%d) output(%d)\n\n&quot;</span>, threadIdx.x, output);</div>
<div class="line">    }</div>
</div><!-- fragment --><p class="startli">Printed output: </p>
<div class="fragment"><div class="line">tid(0) output(0)</div>
<div class="line">tid(1) output(0)</div>
<div class="line">tid(2) output(1)</div>
<div class="line">tid(3) output(3)</div>
<div class="line">tid(4) output(6)</div>
<div class="line">...</div>
<div class="line">tid(31) output(465)</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><p class="startli"><b>Example 2:</b> More sophisticated exclusive prefix sum for one warp </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// A parameterized WarpScan type for use with one warp on type int.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan type provides variants of parallel prefix scan across threads within a CUDA warp...">cub::WarpScan&lt;int, 1&gt;</a> WarpScan;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Opaque shared memory for WarpScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7" title="The operations exposed by WarpScan require shared memory of this type. This opaque storage can be all...">WarpScan::SmemStorage</a> smem_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Perform prefix sum of 2s, all seeded with a warp prefix value of 10</span></div>
<div class="line">    <span class="keywordflow">if</span> (threadIdx.x &lt; 32)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> output, aggregate, input = 2, warp_prefix_op = 10;</div>
<div class="line">        <a class="code" href="classcub_1_1_warp_scan.html#a2695420235a1ace8817a595a6f930d61" title="Computes an exclusive prefix sum in each logical warp.">WarpScan::ExclusiveSum</a>(smem_storage, input, output, warp_prefix_op, local_aggregate);</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;tid(%d) output(%d)\n\n&quot;</span>, threadIdx.x, output);</div>
<div class="line">        <span class="keywordflow">if</span> (threadIdx.x == 0)</div>
<div class="line">            printf(<span class="stringliteral">&quot;computed aggregate(%d), updated warp_prefix_op(%d)\n&quot;</span>, aggregate, warp_prefix_op);</div>
<div class="line">    }</div>
</div><!-- fragment --><p class="startli">Printed output: </p>
<div class="fragment"><div class="line">tid(0) output(10)</div>
<div class="line">tid(1) output(12)</div>
<div class="line">tid(2) output(14)</div>
<div class="line">tid(3) output(16)</div>
<div class="line">tid(4) output(18)</div>
<div class="line">...</div>
<div class="line">tid(31) output(72)</div>
<div class="line"></div>
<div class="line">computed aggregate(74), udpated warp_prefix_op(84)</div>
</div><!-- fragment --> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adec85c76d951c326e592e364aa63c728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75fa41f9103a9e7a6cad20bb3164a1fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. </p>
<p>The <code>aggregate</code> is undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2ae27cea962d6907a1d3d83954a2558"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>. </p>
<p>The <code>aggregate</code> and <code>warp_prefix_op</code> are undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> A call-back unary functor of the model operator()(T local_local_aggregate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> A call-back unary functor of the model operator()(T local_local_aggregate) to be run <em>warp-lane</em><sub>0</sub>. When provided the warp-wide aggregate of input items, this functor is expected to return the logical warp-wide prefix to be applied during the scan operation. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2695420235a1ace8817a595a6f930d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7eb36709cd7f08f204d6176d5c5ec2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. </p>
<p>The <code>aggregate</code> is undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b547cd4f3a07928c411bc3db8eb6d43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>. </p>
<p>The <code>aggregate</code> and <code>warp_prefix_op</code> are undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> A call-back unary functor of the model operator()(T local_local_aggregate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> A call-back unary functor of the model operator()(T local_local_aggregate) to be run <em>warp-lane</em><sub>0</sub>. When provided the warp-wide aggregate of input items, this functor is expected to return the logical warp-wide prefix to be applied during the scan operation. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f0397ded5ce89a8750dc8fe10078f3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad71a09a779d9ee35d1241cf0fa0fae06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. </p>
<p>The <code>aggregate</code> is undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acceb480d6f31b78bdc242340e8b95a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum using the specified binary scan functor in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>. </p>
<p>The <code>aggregate</code> and <code>warp_prefix_op</code> are undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> A call-back unary functor of the model operator()(T local_local_aggregate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> A call-back unary functor of the model operator()(T local_local_aggregate) to be run <em>warp-lane</em><sub>0</sub>. When provided the warp-wide aggregate of input items, this functor is expected to return the logical warp-wide prefix to be applied during the scan operation. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f12aef5d3fa15ff13e59876b2983ce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. </p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3b116a8cd2bcc27a7107e3e789328bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. </p>
<p>The <code>aggregate</code> is undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a889e448ffed5844afa419d9e48bf9754"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The functor <code>warp_prefix_op</code> is evaluated by <em>warp-lane</em><sub>0</sub> to provide the preceding (or "base") value that logically prefixes the warp's scan inputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>. </p>
<p>The <code>aggregate</code> and <code>warp_prefix_op</code> are undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> A call-back unary functor of the model operator()(T local_local_aggregate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> A call-back unary functor of the model operator()(T local_local_aggregate) to be run <em>warp-lane</em><sub>0</sub>. When provided the warp-wide aggregate of input items, this functor is expected to return the logical warp-wide prefix to be applied during the scan operation. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae84a95431640ff2d450c4b0a98dd826e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for thread-lane<sub>0</sub> is invalid. </p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9cd34377974a8d71d043c1930a43d5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. Because no identity value is supplied, the <code>output</code> computed for thread-lane<sub>0</sub> is invalid. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-lane<sub>0</sub>. </p>
<p>The <code>aggregate</code> is undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5bae576a6c632b3cc95628af315065f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int WARPS, int LOGICAL_WARP_THREADS = DeviceProps::WARP_THREADS&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename WarpPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, WARPS, LOGICAL_WARP_THREADS &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_warp_scan.html#a2bfa864e963cb4965139ac1b6c66d1b7">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>local_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WarpPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>warp_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor in each logical warp. The <code>warp_prefix_op</code> value from thread-thread-lane<sub>0</sub> is applied to all scan outputs. Also computes the warp-wide <code>aggregate</code> of all inputs for thread-thread-lane<sub>0</sub>. The <code>warp_prefix_op</code> is further updated by the value of <code>aggregate</code>. </p>
<p>The <code>aggregate</code> and <code>warp_prefix_op</code> are undefined in threads other than thread-lane<sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> CTA barrier is required if the supplied <code>smem_storage</code> is to be reused/repurposed by the CTA.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan functor type </td></tr>
    <tr><td class="paramname">WarpPrefixOp</td><td><b>[inferred]</b> A call-back unary functor of the model operator()(T local_local_aggregate) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary associative scan functor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_aggregate</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> Warp-wide aggregate reduction of input items, exclusive of the <code>warp_prefix_op</code> value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">warp_prefix_op</td><td><b>[<em>warp-lane</em><sub>0</sub> only]</b> A call-back unary functor of the model operator()(T local_local_aggregate) to be run <em>warp-lane</em><sub>0</sub>. When provided the warp-wide aggregate of input items, this functor is expected to return the logical warp-wide prefix to be applied during the scan operation. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Dev/workspace/CUB/cub/warp/<a class="el" href="warp__scan_8cuh.html">warp_scan.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 30 2013 08:55:39 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
